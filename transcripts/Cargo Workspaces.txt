 Welcome back Rust gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. If that sounds interesting to you, click that subscribe button for weekly Rust videos. In the last video, we talked about publishing a crate to crates.io. And in this video, we're primarily going to talk about cargo workspaces. Recall that in chapter 12, we built a CLI program that had a binary crate and a library crate. Now, what happens if the project keeps growing and we have multiple library crates? Well, in that case, cargo workspaces might help you organize your project. Workspaces help you manage multiple related packages that are developed in tandem. Packages in a workspace share common dependency resolution by having one cargo.lock file. Packages in a workspace also share one output directory and various settings such as profiles. All right, now we have enough of the basic information to get started. So with that, let's get rusty. For simplicity, we're going to create a workspace with one binary that depends on two libraries. The first library will have a add1 function and the second library will have an add2 function, which our binary will use. To start off, let's create a directory called addNCD into it. Then let's open this up in VS Code. Next, we'll add a cargo.toml file, which will configure the entire workspace. Now, instead of having a package section like usual, we'll create a workspace section. Next, we can specify the packages in our workspace, which are called workspace members. So to do that, we'll type in members, equal, and then brackets. And here we'll type in the path to our packages. First, we're going to specify the path to our binary, which is going to be called adder. So the path is just adder. Next, we'll open up the terminal and actually create the adder package. At this point, we can also build our workspace by running cargo build from the add directory. At this point, we can see that the cargo.lock file and target directory were generated at the root of our workspace. And if we look at the adder package, you can see that it doesn't have a cargo.lock file or a target directory. Even if we run cargo build from the adder directory, we would still see the output in the top-level target directory. Cargo uses this structure because packages in a workspace are meant to depend on each other. If each package had its own target directory, then when you would compile that package, you would have to also compile all its dependencies. So this reduces the amount of recompilation you have to do. All right, next, we'll add another package or member to our workspace and call it add1. Then we'll type in cargo new add1 and then dash dash lib because we want to create a library. Next, let's navigate to the lib.rs file in our new library. And we'll delete this default test module and add a public add1 function. Now that we have this library with an add1 function, we can use it from within the adder binary. So let's open up the cargo.toml file within the adder directory. Next, we need to specify that our adder binary depends on our add1 library. So let's scroll down to the dependency section and add our add1 library as a dependency. Cargo doesn't assume that crates within a workspace depend on each other. So we have to make this relationship explicit. Next, we'll open up main.rs within the source directory in our adder package. And notice that when we type in the library name, we use an underscore instead of a dash. Then we can modify main to use our add1 function. Here we're declaring a new variable called num and setting it to 10. And then we have this print line statement, which prints hello world, the number we just declared, and then the number plus one. And we get that by calling our add1 function. All right, now let's build our workspace by typing in cargo build at the root of our workspace. Next, we can run our adder binary from the root of our workspace by typing in cargo run dash p to specify the package we want to run and then adder. And as you can see, our add1 function worked. Next, let's talk about external dependencies. If you look at the Explorer tab on the left, you'll see that we have a cargo.toml file for both our add1 package and our adder package. However, we only have one cargo.lock file in the root of our workspace. This ensures that all our crates are using the same version of all dependencies. So if we add a dependency to our add1 package and we add the same dependency to our adder package, they will both resolve to the same version. Making all packages in a workspace use the same dependencies ensures that the packages are compatible with each other. Let's try this out by adding an external dependency. We'll go to the cargo.toml file for our add1 package and add the create rand as a dependency. Then we can go into lib.rs and bring rand into scope. And we'll get a little warning here because we're not actually using rand anywhere in our program. Then from the root of our workspace in the add directory, we can run cargo build. This will bring in and compile the rand crate. And if we look at the cargo.lock file in the root of our workspace, we can see that we have the rand crate here. And if we go a little bit down, you can see the rand crate is defined here as a dependency. Now, even though rand is a dependency of our add1 package and it's defined in the root cargo.lock file, it doesn't mean that we can use rand in any other package in the workspace. For example, if we go into main.rs in our adder package and try to bring rand into scope, we should get an error. If I hover over the red squigglies, you can see that the error is an unresolved import rand. To fix this, we'll need to add rand as a dependency of the adder package inside of adder's cargo.toml file. And now we can bring rand into scope inside main.rs. At this point, both our adder package and our add1 package have a dependency on the rand crate. However, only one version of the rand crate will be downloaded. Next, let's briefly cover testing. Inside our add1 package, we'll add a test module and one test inside lib.rs. The test is called itworks and it simply asserts that calling our add1 function with 2 is going to return 3. Next, we'll open up the terminal and run cargo test from our workspace root, which is the add folder. If I scroll up, you can see that the first section is showing the test that ran for the add1 project. And in this case, we just had one test called itworks, which succeeded. The next section is test that ran for our adder project. And you can see zero tests were found. The last section lists documentation tests that ran for our add1 library. And as you can see, there are zero documentation tests at this point. Running cargo tests like this in the root of our workspace will run tests for all the projects within that workspace. If we want to run tests for a specific project, we can do that by specifying dash p. For example, let's run tests only for the add1 project. So to do that, we'll type in cargo test dash p and then add1. This time we only have two sections. The first section is for our regular tests. We only have one called itworks. And the second section is for our documentation tests, which we have zero of. I'm going to stop here, but I'll give you some homework. If you'd like to continue, then go ahead and add another library called add2, which will have a function similar to add1, except, of course, it's going to add 2 to the integer being passed in. As we're wrapping up talking about workspaces, one thing to note is that if you want to publish the packages within a workspace, you have to publish them individually. Meaning you'll have to cd into each package, in this example, adder and add1, and then run cargo publish from their respective directories. That's about it for workspaces. So next time you find yourself in a situation where you have a big monolithic project with a lot of components that change together, and you want to make them a little more organized by splitting them out into different projects, then consider using workspaces. Next, we'll talk about installing binaries from crates.io with cargo install. Now, this isn't meant to be a replacement for system packages or package managers such as Homebrew, but rather it's a convenient way for Rust developers to use tools built by other Rust developers and published to crates.io. Note that you can only install packages that have a binary target. Remember, packages could have binary targets and library targets, but specifically we need the binary target because we need something we could actually execute. All binaries installed using the cargo install command are stored inside the installation roots bin directory. If you installed Rust using RustUp, then this is the path to the bin directory. Make sure to have this path inside your path environment variable so that way you can run programs installed with the cargo install command. In chapter 12, I mentioned that there's a Rust implementation of the popular tool grep called ripgrep. To install ripgrep, we'll run the following command. Cargo install ripgrep. The second to last line here shows where the binary is installed. And in this case, it's in the cargo bin directory. And the executable is actually named RG. Now that the tool is installed and assuming that your path environment variable is set up correctly, you can simply run RG dash dash help. And you can see the executable is working. One cool thing about these binaries is that you can use them to extend cargo with custom commands. If you have a binary in your path that's prefixed with cargo, for example, let's say that the binary is called cargo dash something. Then you can run this as a sub command of cargo by typing in cargo space something. Cargo is designed this way so you can extend cargo without actually modifying cargo's code. That concludes chapter 14 of the Rustling book. If you enjoyed this video, make sure to smash that like button. And if you want to see weekly Rust content, make sure to hit that subscribe button. And with that, I'll see you in the next one.