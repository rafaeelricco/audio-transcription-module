 Welcome back Rust gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. In the last two videos, we went through part 1 and part 2 of chapter 13 in which we talked about closures and iterators. In this video, we're going to take what we learned about iterators and apply it to our mini GRUP program that we did in chapter 12. So with that, let's get rusty. If you recall from chapter 12, we built a program which searches for lines within a file that contain a specific string. If you haven't already, make sure to check that video out so you're up to date. Part of the implementation of our program was creating this config struct which stores the query, file name, and a case-sensitive Boolean. We also added an implementation block to our config struct which has one constructor function. Our constructor function takes in args as an argument which is a slice of strings and that represents the command line arguments we pass to our program. Then inside the function body, we make sure we have the correct number of arguments, index into the array and clone the string to get the query and file name, check for the case-sensitive Boolean, and finally create a new config struct. Cloning the strings here is inefficient, but we had to do this because args is a reference to an array so we can't take ownership of the strings. Instead of taking an array reference or a slice, let's take in an iterator which we have ownership over, which also means that we have ownership over its arguments. And that way we can remove this clone operation. Let's start by going back to main.rs. On line 7, we're calling the args function in the environment module, which gives us back an iterator over our command line arguments. And then we're calling collect to turn it into a vector of strings. Then we're passing a reference to our vector of strings into the new method on our config struct. Instead, let's just pass in the result of calling the args function. And if we go to the definition, you can see it returns an args struct. And if we go to the definition of that, you can see that the args struct is an iterator over the arguments of a process. Now, this won't compile yet because we have to update the function signature of new. So let's go ahead and do that. Instead of taking a slice, we'll take in the args iterator. And we also need to make args mutable because we'll be iterating over our iterator. Next, we have to handle this little error here, which states that we're missing a lifetime specifier. If you recall the lifetime elision rules, every input parameter that's a reference gets its own lifetime. And if we only have one input parameter, then its lifetime is assigned to all output parameters. That's why we didn't have to explicitly specify lifetimes previously. Now that args is an own type and we're returning a string slice, we do have to specify the lifetime. And it's suggesting here that we set our lifetime to a static lifetime. And that's exactly what we want. And that's because our error here is a string literal, which will live for the duration of the program. Hence, the static lifetime. Next, let's replace this code by using our iterator. First, we'll call args.next. This will return our first command line argument. And because we're not saving it or doing anything with it, we're just discarding it. And that's because the first command line argument is the path to our program, which we don't care about. Next, we'll create a new variable for our query. And here we'll match over args.next. Next returns an option type. So if we have a valid argument, we'll extract that argument from some and return it. Otherwise, we'll return an error specifying that we didn't get the query string. Then we'll do something similar for the file name. And that's it. We're done. As you can see, we didn't have to call clone. And that's because when we call args.next and we get a sum variant, the string inside sum is an own string. And then we're passing it into query. So query is now taking ownership of the string. File name is taking ownership of its string. Then we're passing query and file name into config. So at this point, config takes ownership of the strings. Next, let's turn our attention to the search function, which we could simplify using iterator adapter functions. In our function body, we create a new results vector. Then we get all the lines in our string and iterate over them. For each line, we see if it contains our query. And if it does, we push it onto the vector. And then at the end, we return the vector. Let's replace this entire function body. First, we'll get an iterator to all the lines in our string by calling contents.lines. Now that we have all our lines, we'll call the filter adapter method. Here we're saying filter to only the lines that contain our query string. And then finally, we'll call our collect consumer method to turn our iterator into a collection. Here, Rust knows which collection we want because it's specified as the return type. And that's it. We accomplished the same exact thing, except this time we used the methods provided to us by iterators. Now, you might be asking yourself, should I use loops or iterators? Is there a performance hit for using iterators? And the short answer is no. Rust follows the zero cost abstraction principle, which means that using higher level abstractions like iterators over loops doesn't have a meaningful impact in terms of performance. So using loops or using iterators is about the same in terms of speed. At the end of the day, it comes down to preference. And Rust engineers tend to prefer iterators because it's a higher level of abstraction and you get access to all those nice methods, some of which we just used. That concludes chapter 13. If you like this video, make sure to smash that like button. And if you want to see weekly Rust content, make sure to subscribe to the channel. So with that, I'll see you in the next one. Bye.