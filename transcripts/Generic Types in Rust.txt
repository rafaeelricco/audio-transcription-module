 Welcome back to Let's Get Rusty. My name is Bogdan and this channel is all about the Rust programming language. If that sounds interesting to you, make sure to subscribe for weekly Rust videos. In the last video, we went over Chapter 9, which covered air handling. In this video, we're going over Chapter 10, which covers generics, traits, and lifetimes. Now, those are each pretty big subjects, so we'll cover them each in a separate video. So with that, let's get started with generics. Generics, traits, and lifetimes are all ways to reduce code duplication. But first, let's start off with an example of reducing code duplication by extracting logic out into functions. Here we have a variable called numberlist, which stores a vector of integers. And then we have some code below that finds the largest integer in this vector. First, we create this mutable variable and set it equal to the first number in our vector. And then we just loop through the rest of the numbers. And if we happen to find a number that's larger than the currently stored number, we change the largest variable to that number. So at the end of this loop, we will have our largest number. And then we just print the largest number out. This code works, but what happens if we want to find the largest number in a different vector? Well, one thing we could do is just duplicate this code like so. Here we have almost the same code as up above. The vectors are different, but the logic for finding the largest number is completely the same. To reduce this code duplication, the obvious step here is to take the logic to find the largest number and extract that out into a function. We'll call our function getlargest. And then we can change the code up above to use our function. As you can see, there's a lot less duplication now. So let's go ahead and run our program. And we get the expected output. In the first vector, the largest number is 100. And in the second vector, the largest number is 6,000. This is a great first step, but our getlargest function is tied to a concrete set of arguments. In this case, number list, which has to be a vector of sine 32-bit integers. What happens if we want to use the same logic over a slightly different set of arguments? Let's say that we want to find the largest character in a vector. So here in our second call to getlargest, instead of passing in a number list, what we want to do is pass in a char list, like so. Here we get some red squiggly lines indicating an error. If we hover over it, it says we have mismatched types. What we expect is a vector of sine 32-bit integers, but what we pass in is a vector of characters. So how do we solve this problem? Well, one way is duplication. So we can go ahead and copy this getlargest function. Then let's change it to getlargest char. And then instead of passing in a vector of integers, we'll pass in a vector of characters. And then we'll also return a character. Now we could take this function and use it here to get the largest character. And we don't have any more errors. Now this works, but again, we want to reduce duplication. So instead of writing two functions, let's modify our original function to take in both sets of arguments. And we can do that with generics. First, we'll specify that our getlargest function uses generics. Generic types are specified inside of angle brackets right after the function name. So here we have a generic type called T. Now this is convention. If you have one generic type, you typically call it just the letter T, which stands for type. So we can go ahead and write that out. But for keeping things concise, let's just call it T. You can also have multiple generic types by using a comma to separate them. So here we have T, we can add U, we can add anything else we want. But we only need T for now. Now that we have our generic type defined, we can use it inside our function. And the first place we want to use it is inside our vector definition here. Instead of taking in a vector of integers, we want to take in a vector of T. So a vector of a generic type. You can see down here in these little gray type annotations that when we get values out of our vector now, they're of type T. And the second place we want to use our generic type is in the return value. So we're not returning an integer. We're returning whatever the generic type is. Now our function mostly works, but we do get this little error here, which says that we cannot use the greater than operator on our type T. This makes sense because T is generic. It could be anything. So it could also possibly be something that we cannot compare. In order to fix this problem, we need to restrict our generic type. Instead of saying our generic could be of any type, we want to say our generic could be of any type that could be compared. In order to do this, we need to use traits, which we'll learn about in the next video. But really quickly, let's fix this function with traits. So here we're just saying that our type T has to be a type that can be ordered and a type that we could copy, which remember our primitive types like integers or characters. And again, we'll learn about this in the next video. So don't think too hard about the syntax here. So now we could take our get largest function and we can use it with characters as well as numbers. We could also use generics with structs. So here we have a struct called point with two fields, x and y. And both x and y are 32 bit signed integers. And then in main, we create a new point. But what happens if we want to say create a new point with floating point numbers instead of integers? Well, we would get an error here that says mismatched types, right? Because we have x and y set to 32 bit integers, but we want floating point numbers. Well, generics can help us in this situation as well. So what we could do is add generics to the point type. And just like functions, we specify generics after the name of our struct, which is point inside of angle brackets. So here I specify the generic type t again, and we can use that by setting x and y to t. And after saving, both our first and second point are valid now. Now let's add a third point. And in this third point, x is an integer, but y is a floating point number. So we have different types for x and y. And this gives us an error saying we have mismatched types. And that's because in our struct here, we say both x and y are of type t. So they're generic, but they have to be the same type. But as I mentioned before, we can have multiple generic types defined. So let's add another generic type besides t. And we'll call it u. And then we'll change y to be of type u. So here what we're saying is x is going to be of a generic type t, and y is going to be of another generic type u. They could be the same type. So for example, our previous points still work, but they could also be different types. So now our third point works as well. We can also use generics inside of enum definitions. And in fact, the two most popular enums we've been using in past chapters, the option enum and the result enum are implemented using generics. So for the option enum, we have one generic, which is t, and that's used in the some variant. If we get the some variant, then something is returned, but we don't want to specify exactly what that thing is. And in the none case, we don't return anything. With the result enum, we use two generics. One that specifies the OK value being returned, which is t here. And then the other that specifies the error. So if we get an error, we return this generic error type. Let's go back to our point struct to see how we can define functions using generics on structs or enums. Here we have our point type, which has a generic parameter t, and both x and y are set to t. Now let's define a method on our point struct. If you recall, we define methods in implementation blocks. So let's define an implementation block. We want our implementation block to use generics. So after impl, we're going to write angle brackets and our generic inside of them. In this case, t again. Then we write point, again, angle brackets with t, and then curly brackets. Inside our implementation block, we'll declare a method called x. x takes a reference to self, which is the point instance we're operating on, and then returns a reference to the x field, which is a generic type. So here we return a reference to t. Note that we can use a different name for the generic type here. So for example, let's change the t's to use. This just shows that the generic here is not tied to the generic specified up here. So all this is saying is that we have an implementation block which uses a generic, and we're going to call it u. And then this is saying this implementation block is for a point with a type parameter that is set to our generic. So basically, the type parameter could be anything. And then we simply define our function. To make this a little more clear, let's define another implementation block on point with a concrete type parameter. So here we're defining an implementation block, and that implementation block is only for points that have a type parameter of a 64-bit floating point number. And then we define a function called y, which returns the y value of the point. This means that the x method is going to be available to points of any type. But the y method is only going to be available to points where the x and y values are floating point numbers. To demonstrate, let's scroll back down to main, where we have a point defined with integer types, and create a new point with floating point numbers. Our first point is called p, and x and y are set to integers. So if we try to see what methods are available on p, we can see that x is available as a method, but y is not. And then we can do the same thing for p1, which is our next point, and x and y are floating point numbers in this case. So you can see, in this case, both x and y are available. Alright, now let's go through a more complex example. Here we have our point type again, except now we have two generics, t and u. So x is going to be one type, and y is going to be a different type. Then we define an implementation block, and our implementation block has some generics, t and u. And it's going to be an implementation block for our point struct, and then we define a function called mixup. Now mixup has its own set of generics, v and w. These generics are scoped to the mixup function. Mixup takes self as the first argument, and the second argument is called other. It's going to be another point, and this point is going to use the v and w generics defined right here. Now why would we use v and w here instead of t and u? Well, it's because we want this point that's being passed in to potentially have different types than the point we're calling the function on. Our return type is also a point, and here we mix up the generics. So first we have t, which comes from the point we're calling the method on. And then we have w, which comes from the point being passed in. Looking at our point definition, we could see that the first generic specifies the type for x, and the second generic specifies the type for y. So this return type is saying x is going to come from the point the method is called on, and y is going to come from the point being passed in. And that's exactly what we see happening inside the method. We return a new point and set x to self.x, so the x value of the point the method is being called on. And y is set to other.y, so the y value of the point being passed in. Hopefully that makes sense. If it doesn't, you can pause the video and read through the code. But let's go through the example in main. First we declare a point called p1, and the x value is going to be an integer. The y value is going to be a floating point number. Then we declare another point called p2. Its x value is going to be a string, and the y value is going to be a character. Finally, we declare a third point called p3, and its value is going to be set to the output of calling mixup on p1 and passing in p2. Mixup is going to return a new point, and the x value of this new point is going to be self.x, which in this case is p1.x, which is 5. And then y is going to be other.y, so the point that's passed in, which in this case is p2. And p2.y is going to be c. So the x value should be 5, and the y value should be c. Let's go ahead and run our program. And like expected, we can see that x is 5 and y is c. The last thing I want to talk about is performance. Generics are great because they allow us to reduce duplication. For instance, in this case, we have two sum variants of the option enum. One is an integer, and one is a floating point number. Instead of defining two versions of the option enum, we can define one version and use a generic for the sum variant. Luckily for us, this does not incur a performance hit. And that's because at compile time, Rust will actually turn the option enum into two option enums, one for the 32-bit integer and one for the floating point number. And it'll look something like this. We have one option enum called option underscore i32 for the 32-bit number, and then another one for the floating point number here. And then in main, we use either one depending on which type we want. If you enjoyed this video, make sure to give it a like. And in the next video, we're going to go over traits. So if you want to see that, make sure to hit subscribe for weekly Rust videos. With that, I'll see you in the next one.