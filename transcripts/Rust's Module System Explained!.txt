 Welcome back to Let's Get Rusty. My name is Bogdan and this channel is all about the Rust programming language. If that sounds interesting to you, make sure to poke that subscribe button. In the last video, we went over chapter 6 in which we talked about enums and pattern matching. If you haven't already, make sure to check that video out. In this video, we're going over chapter 7 in which we'll talk about managing growing projects using packages, crates, and modules. In previous videos, we've been writing all our code in one file which lives in the default module. But as our project grows, we need a way to organize our code and we also need a way to encapsulate our code. For example, imagine you had some chunk of code that dealt with authentication. You don't want the rest of your code to know everything about how the authentication code works. Maybe you just want to expose a method that's called login and keep the rest of the code hidden from the rest of your program. To address these needs, Rust has a module system that starts with a package. When you type in cargo new, you create a new package and a package stores crates. A crate could either be a binary crate, so code you can execute, or a library crate, which is code that can be used by other programs. Crates contain modules. Modules allow you to organize a chunk of code and control the privacy rules. So going back to the authentication example, let's say you have a library crate that contains an authentication module. You can then make the code inside your authentication module private, but expose one public login method. If we wanted code outside of the authentication module to call the public login method, it would have to specify a path to that login method. That's the basic module system. Rust also has something called workspaces, which are meant for very large projects and allow you to store interrelated packages inside the workspace. We'll talk more about that in chapter 14. With that background, let's jump into creating some packages and crates. Let's first create a new package called my project. To do that, we'll type in cargo new and then the name of our package. We'll cd into the directory and open it in VS code. Here we have the default file structure for our package. We can open up cargo.toml and at the top you see we have package and then the name, which is my project. Now, as I've mentioned before, packages store crates and we can actually define crates inside of our cargo.toml file. Here, we don't see any crates defined. So does that mean our package doesn't have any crates? Well, actually, we do have a binary crate and that's because if you look in the source directory, we have a file called main.rs. Rust follows the convention that if you have main.rs defined in your source directory, then a binary crate with the same name as your package will be automatically created and main.rs will be the crate root. The crate root is the source file that the Rust compiler starts at when building your crate. It also makes up the root module of your crate. There's also a similar convention for library crates. So in our source directory, let's create a file called lib.rs. If lib.rs is defined in the root of your source directory, then Rust will automatically create a library crate with the same name as your package and lib.rs will be the crate root. So in this case, even though we don't have any crates defined in our cargo.toml file, our package actually does have two crates following the lib.rs and main.rs convention. The last thing to do here is to mention some rules around crates. The first rule is a package must have at least one crate. The second rule is a package could have either zero library crates or one library crate. And lastly, a package could have any number of binary crates. In our case, we have one library crate and one binary crate. If we wanted more binary crates, we would create a folder called bin. And in this folder, we could define files. So in this case, let's just do a file called another one. And each file in this folder will represent another binary crate. Now that we understand packages and crates, let's talk about modules. And to do that, we'll create a new package called restaurant. And we want this package to contain a library crate. So to do that, we'll specify dash dash lib. We'll CD into our directory And open the package in VS code. Here we get a file structure that looks similar to our previous package. But if we go to the source directory, instead of main.rs, we have lib.rs defined by default. Here we get a test module automatically added for us, which we don't need right now. So let's go ahead and delete that. Our goal is to create a library that will help run a restaurant. And we'll think about a restaurant as two parts, the front of the house, which represents the area where the customers are, and the back of the house, which represents where the food is being made, dishes are being cleaned, and where the manager would typically be. To start off, I'll paste in some code, which represents the front of the house. At the top, we have a module called front of the house. Modules are specified using the mod keyword, followed by the name of the module, and then curly brackets. Inside of the front of the house module, we have two other modules hosting and serving. Inside of the hosting module, we have two functions related to hosting duties, add to waitlist and see at table. Inside of the serving module, we have three functions that are related to serving duties, take order, serve order, and take payment. Modules can contain other modules inside of them. They could also contain structs, enums, constants, traits, and so on. Structuring our code this way keeps it organized. If in the future, for example, we wanted to add the ability to seat people at a VIP table, we would know exactly where to put that function. Looking at the Rust book, we could see what our module tree looks like. At the top, we have a module called crate. Yes, it's a little confusing that a module is called crate, but bear with me. Crate is a module that gets created by default for our crate root, which is lib.rs. Inside of that, we have the front of house module. And inside of that, we have two modules, hosting and serving, each of which have functions defined in them. A good analogy is to think about the module tree, like the folder or directory tree on your computer. Now let's talk about paths. Going back to the directory analogy, if you wanted to reference a file inside your directory tree, you would need to specify a path to that file. In the same way, if you wanted to reference an item in your module tree, let's say a function, you would need to specify a path to that function. Here, I've simplified our front of house module a bit. Now, we just have a hosting module inside with one function, add to waitlist. Outside of the module, we have a function called eat at restaurant. And inside this function, we want to call add to waitlist. To do so, we need to specify the path to that function. In Rust, a path could either be an absolute path or a relative path. Paths are specified using identifiers separated by double colon. So for example, here we have an absolute path, and it starts at the root of our module tree with crate. Inside of crate, we reference front of house and then hosting, and then finally our function. Relative paths start from the current module. So in this example, our function eat at restaurant is inside of the crate module, which means we can start with front of house and then reference hosting, and then our function. Now notice we have some errors here. If we hover over the red squigglies, we could see that it says the hosting module is private. This is because of Rust's privacy rules. By default, a child module and everything inside of it is private from the perspective of the parent module. So in this case, front of house can't see hosting or anything inside of hosting. On the flip side, child modules are able to see anything that's defined in their parent modules. This system allows us to hide implementation details by default, and only expose the functions we need to to the outside world. In this case, we do want to expose our add to waitlist function. And to do that, we can use the pub keyword. So first, let's expose our hosting module. To do that, we'll include the pub keyword in front of mod. As you can see, our error moves from hosting to our function. And that's because at this point, hosting is public, but our function is still private. To fix this, let's also add the pub keyword in front of our function definition. And now we're able to access the add to waitlist function outside of the hosting module without any issues. Let's look at another example with relative paths using the super keyword. In this example, we have a function called serve order defined in the top create module. Then we have the back of house module, which has two functions, fix incorrect order, and cook order. Inside of the fix incorrect order function, we're able to call cook order, because that's defined in the same module. And we're also able to call serve order by using the relative path. And here we specify super, which allows us to reference the parent module, which in this case is crate. And then we specify the function we want to call. Now let's talk about privacy rules when it comes to structs using another example. In this example, we have a module called back of house, and inside the module we have a struct called breakfast, which represents a breakfast meal. The struct has two properties, toast and seasonal fruit. Then we define an implementation block, which has an associated function for our struct called summer. This function will build a summer breakfast meal. It takes in a string called toast, and then creates a new breakfast struct with toast set to the string we passed in. And seasonal fruit is something the restaurant will decide on. So we hard code it to peaches. At the bottom, we have a function called eat at restaurant. And inside of this function, what we want to do is call the summer associated function to create a new breakfast meal. But you can see we get a couple errors. Our breakfast struct is private by default, so we can't access it. Also, you can see that our summer associated function is also private by default. To fix these errors, let's add the pub keyword to both the breakfast struct and the summer associated function. Our errors are gone, which is great. So now let's say after we get our meal, we'd like to change the toast from rye to wheat. To do that, let's try reassigning the toast field on our meal variable. And here you can see we get an error. The error says the toast field is private. Even though our struct is public, by default, fields within the struct are private. So to fix this, we can explicitly mark toast as a public field. And now we're able to reassign. Also note that in order to create a new breakfast struct, we need to use the summer associated function. We can't create a breakfast struct directly inside of eat at restaurant. And that's because the breakfast struct includes a private field, seasonal fruit. If we did attempt to create the breakfast struct directly, like so, we would get an error, which says that the seasonal fruit field is private. So we can't create the struct directly. Let's look at another example using enums. Again, we have a module called back of house. And inside we have an enum called appetizer, which has two variants soup and salad. Then at the bottom inside of our eat at restaurant function, we create two orders by specifying the variant of appetizer we want. As expected, we get errors here because appetizer is private by default. To fix this, let's make appetizer public. Notice that in our eat at restaurant function, we are using the soup and salad variant, but up here we didn't have to specify explicitly that they're public. Enums wouldn't be very useful if their variants were private. So by default, if you mark an enum public, all of its variants are public as well. All right. Now let's take a look at yet another example so we could talk about the use keyword. In this example, we have a module called front of house, which contains a module called hosting, which contains a function called add to waitlist. And then we have a function at the bottom here, eat at restaurant, which calls our add to waitlist function. Specifying the full path when calling these functions isn't very pretty or ideal. So to get around that rust provides the use keyword. Use allows you to bring a path into scope. So as an example, let's bring the hosting module into scope. Now that our hosting module is in scope, we can use it without specifying front of house. Here we specify the path as an absolute path, but we could also specify it as a relative path. To do that, let's change crate to self. Here self is referencing the current module, and then we can specify front of house and hosting. Now here instead of bringing the hosting module into scope, we could have gone further and brought the add to waitlist function into scope. That way we wouldn't even have to specify hosting here. However, in Rust, the idiomatic way to bring functions into scope is to bring the function's parent module into scope. And that's because we're still minimizing the path we have to specify, but we're also making it clear that this add to waitlist function is not a local function. It's actually defined inside of another module. On the other hand, if you're bringing enums, structs, or other items into scope, it's idiomatic to specify the full path. The exception to this is if you're bringing in two items, let's say two structs from different modules into scope and they have the same name. In that case, you would want to bring the parent modules into scope so that the names don't conflict. As an example, let's take a look at the following code. We have two functions which use a result type, but each uses a different result type coming from a different module. To prevent the names from conflicting, we bring the parent module into scope, and then reference the result type by specifying the parent module first. Another way of doing this is to rename one of the result types when we bring it into scope. So in this example, we bring the result type from the format module into scope, and then we bring the result type from the IOModule into scope, but we rename it to IOResult. And we can do this using the as keyword. And then our functions could reference each type by its name. All right, now let's go back to our restaurant example. So we could talk about re-exporting. Like before, we have our front of house module, which has our hosting module inside and the add to waitlist function. Then at the bottom, we have the eat at restaurant function, which calls add to waitlist. And we don't have to specify the full path because here we bring the hosting module into scope. Now let's say that we want some code that's external to this file to also have access to the add to waitlist function. Well, currently it would not have access. The only thing it would have access to is eat at restaurant because we've made this function public. If we want external code to be able to call the add to waitlist function directly, we need to re-export the hosting module. To do this, we simply add the pub keyword in front of our use statement. Now we're bringing the hosting module into scope by using the use keyword, but we're also marking this public. So external code could reference hosting as well. The use keyword allows us to bring items into scope within our program, but it also allows us to bring in items from external dependencies into scope. For example, let's go to our cargo.toml file and add the ran dependency. Then inside of the lib.rs file, we could bring the range trait into scope. The range trait is brought into scope from our external dependency. And now that it's in scope, we could use it to create a random number. If you remember our guessing game, this is the same exact code. And here I'm just creating a number from 1 to 100. Now let's say we wanted to bring a few more items from rand into scope. Now we could list all of these items on a separate line, but given that they all start with rand, we can refactor this into one line using nested paths. Here we're specifying the common part of the path, which is rand. And then we have two colons, curly brackets, and the nested paths. If you're bringing a lot of items into scope, using nested paths can help you keep your code clean and concise. Let's see another example. Here we're bringing io into scope from the standard library, and we're also bringing write into scope, which is defined inside of io. The common path between these two use statements is stdio. So let's write this in one line. Here we're using nested paths again. So we specify stdio, and then here we say self to refer to io itself, and then write. Lastly, we'll talk about the glob operator. Let's say that we wanted to bring all the public items underneath io into scope. To do that, we'll specify stdio and then asterisks. And now all public items underneath io are in scope. Up until this point, we've defined multiple modules in one file. But as you can imagine, if your program grows, a module might get large in size, and in that case, you might want to move your module definition into another file. Let's see how that's done by moving the definition of our front of house module into a different file. To start, we'll create a new file in the root of our source directory called frontofhouse.rs. Then we'll take the contents of frontofhouse. And move it into our new file. Going back to lib.rs instead of curly brackets, after our frontofhouse.module definition, we'll replace it by just adding a semicolon. This tells Rust, define the frontofhouse.module here, but get the contents from a different file with the same name as the module. To continue with our example, let's go back to frontofhouse and extract the definition of the hosting module into a separate file. To get started, we'll create a new directory called frontofhouse. And in that directory, we'll create a new file called hosting.rs. Then we'll go back to our frontofhouse file and take the contents of the hosting module and paste it into our hosting.rs file. Finally, we'll go back again to our frontofhouse file and remove the curly brackets, replacing them with a semicolon. Going back to lib.rs, we can see that everything still works as expected. Let's go through this one more time. We can declare modules in Rust using the mod keyword and we can define the contents of our module inline if we use curly brackets as we've seen before. But if we want the contents of our module to be in a different file, then we can just use a semicolon here and put the contents of the module in a file with the same name as the module. In this case, we declare frontofhouse here and the contents are in a file called frontofhouse.rs. Similarly, we can declare child modules and have their content live in a different file. But for child modules, we need to have the corresponding file, which in this case is hosting.rs live in a directory with the same name as the parent module, which in this case is frontofhouse. Whew, that was a lot. In this video, we learned about Rust module system, we learned about packages, crates, modules, privacy rules, paths, bringing paths into scope, re-exporting, and separating out the content of a module into a separate file. If you like this video, make sure to give it a thumbs up. And if you want to see more Rust content on a weekly basis, make sure to subscribe. Lastly, if you have any specific Rust topics you want me to cover, leave a comment down below to let me know. And with that, I'll see you in the next one.