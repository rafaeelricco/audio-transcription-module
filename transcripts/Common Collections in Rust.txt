 Welcome back to Let's Get Rusty. My name is Bogdan and this channel is all about the Rust programming language. If that sounds interesting to you, make sure to tap that subscribe button so you can get Rust videos every single week. Last time we went over chapter 7 in which we talked about managing large projects using Rust's module system. In this video we'll go over chapter 8 which talks about common collections. Collections allow you to store multiple values but unlike arrays or tuples, collections are allocated on the heap meaning the size of the collection could grow or shrink as needed. Specifically we'll talk about vectors, strings, and hash maps. So with that let's get started. The first collection type we'll talk about are vectors. Here I created a new package called collections and in main I've defined an array called a and it contains sine 32-bit integers. So now let's create a vector of sine 32-bit integers. We'll call our vector v and we'll specify the type as a vector of sine 32-bit integers and then we'll set that equal to vec colon colon new. Here we're calling the new function on the vector type which will create an empty vector. Now vectors can hold any type of values and because we're not initializing the vector with any values Rust can't infer what type we want. So here we have to specify the type using generic syntax and in our case it's sine 32-bit integers. Now a vector can grow in size so even though this vector is empty right now we can add elements to it. To do that let's make the vector mutable and then we can call a method called push to push elements onto the vector like so. So here we're pushing 1, 2, and 3 onto our vector. Now if we wanted to create a vector and initialize it with values at the same time Rust has a convenient macro for that. So let's create another variable called v2 and we'll set that equal to vec exclamation point and then specify the values we want to initialize the vector with. This looks very similar to our array initialization except that we have the vec macro specified in the beginning here and notice that we didn't have to specify the type explicitly and that's because Rust couldn't infer the type from the values we passed into the macro. Note that vectors just like any other type stored on the heap will be dropped when they go out of scope. So to illustrate this let's put our v2 variable in its own scope. When this scope ends which is right here, v2 will be dropped. Also all the elements inside of our vector will be dropped as well. Now let's talk about accessing elements inside of a vector. There are two ways to access elements and the first way is to directly reference an index in the vector. As an example here I have a vector called v with five elements and what we'll do is access the third index. Here we create a variable named third which is equal to ampersand v and that specifies a reference to our vector and then we use brackets to specify the index we want and it's zero based. So if we want third index we specify the number two and then we just print our variable. Let's go ahead and run this program. We'll type in cargo run and we see that the third element is three which is correct. Now the problem with this approach is that we can specify an invalid index. For example instead of two let's put 20 here. Now we don't have an element at the 21st index. So when we try to do cargo run we'll get an error. Here we get an index out of bounds error which says that the length of our vector is 5 but the index we specified is 20. Now notice that this is a runtime error. If we used an array and tried to access an index that was out of bounds we would get a compile time error. So the program wouldn't even run until we fix the error. And that's because with arrays we know the size of the array at compile time. But with the vector we don't know the size at compile time. Vectors are stored on the heap so they could be of variable size. All that to say if you directly reference an element in a vector then you're saying I expect my program to crash at runtime if an invalid index is used. But let's say you don't want your program to crash if an invalid index is used. Instead you want to handle that case gracefully. In that situation Rust provides a safer way to access elements in a vector using the get method. Let's change this 20 back to 2. And at the bottom here we'll use the get method to access the third index. Now here instead of getting a reference to the third element directly we're calling the get method and passing it our index. And the get method as you can see here returns an option. You might recall from my video on enums that the option enum represents some value or no value. Here we use a match expression to handle both the some case and the none case. In the some case we get our integer and store that in a variable called third and then we print the variable out. In the none case we print out that there is no third element. Let's comment out the print line statement up here and run our program again. And we get the expected output. The third element is 3. Now let's change this to 220. And we'll run our program again. This time instead of throwing a runtime error our get method returns none because there is no element at the index we specified. So we execute the code in our none branch. So again if you want to handle index out of bounds errors gracefully without crashing your program you would access elements on your vector using the get method. Now when we access elements in a vector we are getting a reference to that element. And if you recall in the video I did about ownership and rust there are some rules around references. Namely that you cannot have a immutable reference and immutable reference to the same thing at the same time. For example let's say after we create this third variable up here. And before we print it out we want to add an element to our vector like so. And we'll need to make our vector mutable. Now if I uncomment this print line. You see that we get an error. And the error states we can't borrow v as mutable because it is already borrowed as immutable. On line four we take an immutable reference to a value in the vector. On line five we take a mutable reference to push a new element onto the vector. And then on line six we use our immutable reference that we created on line four. This is a problem because when we have an immutable reference to something we expect the underlying value to not change. But if we have a mutable reference to the same thing then the underlying value could change. And the way that happens with vectors is that when we push a new element onto a vector we might need to allocate more memory to make room for that new value. And when we do that we need to move all the elements in our vector to new memory locations. And if that were to happen then our variable we declared here on line four would be pointing to something else. Now let's talk about iterating over elements in our vector. For example let's say we want to iterate over all the elements in our vector v and print them out. To do that we can use the for in loop. So we'll type out for i in and then we'll take a reference to our vector and print out each element. Let's run our program and we get our list of elements printed out. What's happening here is we're looping through all the elements in our v vector and we're taking an immutable reference to each element and then printing it out. But we could also take a mutable reference and then modify the value. Here we're using the dereference operator to get the underlying value and add 50 to it. We'll learn more about the dereference operator in chapter 15. Underneath this for in loop let's print out all our values again and then we'll run our program. And you can see that all the values in the vector have 50 added to them. The last thing I want to talk about with regard to vectors is storing enum variants inside of a vector. As I've mentioned before vectors can only store one type of data. But let's say we want to store different types of data. In this example we want our vector to represent a row of cells in a spreadsheet. Each cell could store either an integer, a floating point number, or a string. In order to represent this in a vector we can create an enum that represents the cell. We'll call a spreadsheet cell. And then create variants for each type of data. In this case we have an int variant, a float variant, and a text variant. Now remember that all of these variants are under the same type which in this case is spreadsheet cell. So we could create a vector of spreadsheet cells. And then inside the vector we could have different variants. Now the only catch is when you reference a specific element inside of the vector you have to use a match expression to figure out which variant of the enum it is. And that's because our vector is of type spreadsheet cell. So here we're referencing the second element in our vector. And we're saying if it's an integer then print out the integer. And if it's anything else print out not an integer. Alright, now let's talk about strings. And before we start I just want to say that strings are pretty dang complicated. In higher programming languages the complexity of strings is abstracted away from the programmer. But in lower programming languages such as Rust we have to deal with that complexity. So with that preface let's talk about what a string actually is. In Rust strings are stored as a collection of UTF-8 encoded bytes. So let's just start with a collection of bytes. We see a string as letters and numbers but a computer only understands ones and zeros. So in memory a string is just a list or a collection of ones and zeros. Now a program needs to be able to interpret those ones and zeros and print out the correct characters. And that's where encoding comes into play. So what is the UTF-8 encoding? In order to understand UTF-8 we first have to understand ASCII or the American Standard Code for Information Interchange. ASCII is a string encoding so it defines how to take ones and zeros and turn it into a string or take a string and turn it into ones and zeros. The problem is each ASCII character is stored as a byte and only seven bits of that byte are used to represent the character. That means ASCII can only represent 128 unique characters. And so ASCII only represents the English alphabet, some special characters, and a few commands. Now because ASCII only represents English characters, other countries created their own encoding standards that could represent characters in their language. Now this is problematic because with all these different encoding standards, how does the program know which standard to use when parsing a collection of bytes? And so to solve this problem, Unicode was created. Unicode is a universal character set, meaning that it represents characters from all the well-known languages, and also things like emojis. Another great part of Unicode is that it's backwards compatible with ASCII. And that's because the first 128 symbols of Unicode are ASCII characters. So you can use a Unicode encoding to parse ASCII text. And now that we understand Unicode, let's talk about UTF-8. UTF-8 is a variable width character encoding for Unicode. Variable width because each character in UTF-8 could be represented as one byte, two bytes, three bytes, or four bytes. This is very important. Remember that in ASCII, each character is represented by one byte. But with UTF-8, each character could be a different size in terms of bytes. UTF-8 is the most popular encoding of Unicode, so you've probably seen it before. And that's why in Rust we use UTF-8 as well. Now that we have some background about strings, let's talk about creating a new string. Just like with vectors, we can use the new function to create an empty string. We can also define string slices like so. We could take the string slice and turn it into an own string by using the toString method. Lastly, we can create an own string from a string slice by using the from function. Remember that strings are UTF-8 encoded, so we can write strings in English, but we could also write strings in many other languages as well. Now let's talk about appending to a string. Just like a vector, a string can grow or shrink in size. Here we create a new string called S, and it contains foo. And then we can use the push-stir method to append bar to the string. And this method takes a string slice, because we don't actually want to take ownership of the string being passed in. We can also append characters to the end of a string using the push method. At the end of these operations, our string will be foo bar! We can also append strings using the plus operator. So here we have S1 and S2 defined. And then S3 is equal to S1 plus a reference to S2. What's happening here is we're moving ownership of S1 into S3, and then we're taking all the characters in S2 and appending them to the end of S3. And this saves a little bit of memory compared to copying both strings. Also note that because we moved ownership of S1, if we try to use S1 after we've declared S3, then we'll get an error. And the error states that we cannot borrow a value after it's been moved. We can also concatenate these strings using the format macro, like so. In this case, we're combining S1 and S2, and storing that in S3. The format macro doesn't take ownership of these strings, so we can still use S1 and S2 after this call. Now let's talk about indexing into a string. Here we have the string hello, and what we want to do is get the first character. In higher programming languages, this could simply be done by using brackets and specifying the index of the character you want. But in Rust, you see we get an error, and it says that our string cannot be indexed by an integer. Why is this? Well, remember that a string is a collection of bytes. So what's the length of our hello string? You might say five, because there are five characters. And that would be correct, because each of these characters is one byte. However, let's change hello to здравствуйте, which is hello in Russian. Now what's the length of this string? You might say 12, because you see 12 characters. But actually, it's 24, because each of these characters is two bytes long. Remember, in UTF-8, strings could be one to four bytes long. So if we wanted to get the first character in our string using this syntax would not work, because here we're specifying the first byte in our collection of bytes. But the first character is two bytes, so this would only give us half the character, which is not what we expect. To better understand this, let's talk about the three relevant ways a word is represented in Unicode. So here we have the Hindi word namaste, and it could be represented in three different ways. The first way is a collection of bytes. And you can see here, there are 18 bytes in this word. The second way is scalar values. You can think about these as building blocks in Unicode. They could represent a full character, or parts of a character. And in Rust, this is what the char type refers to. And lastly, we have grapheme clusters. This is what you and I would consider a character. So namaste has four grapheme clusters. The problem with indexing into a string is Rust doesn't know what we want to receive bytes, scalar values, or grapheme clusters. So we have to use more specific methods. In order to access the bytes of a string, we can use the bytes method, like so. The bytes method returns a collection of bytes, and here what we're doing is iterating over every byte and printing it out. So let's go ahead and run our program. And you can see we get a list of bytes. Similarly, we can iterate over our scalar values using the chars method, like so. Let's go ahead and run our program. And here we get our list of chars. And lastly, we have grapheme clusters. And you might be thinking, great, this is what I wanted all along. Well, unfortunately, in order to keep the Rust standard library lean, the ability to iterate over grapheme clusters is not included by default. To iterate over grapheme clusters, we need to import a crate. Let's head over to my cargo.toml file. And you can see I already included this unicode segmentation crate, which will allow us to iterate over grapheme clusters. Since I already have this included, let's go back to our main.rs file and bring it into scope. Then we can scroll down and add the following code. Here, we're calling the graphemes method on our string, which will give us a collection of graphemes. We're passing in true to get extended grapheme clusters, which we want, and then printing out each individual grapheme. Let's go ahead and run our program. And you can see we get the characters we'd expect. As you can see, strings are pretty complex and in Rust, we have to deal with that complexity. If you're still confused, don't worry, I plan to make an entire video about strings in the future. But for now, let's continue on to hash maps. Hash maps allow you to store key value pairs, and those keys and values could be of any type. Also, it uses a hashing function to determine how to place those keys and values in memory. In order to create a new hashmap, first we need to bring the hashmap type into scope from the standard library, like so. Next, let's define some keys. In this case, we want to track a game. So we want the keys to be the team name and the values to be the team score. Here we have team blue and team yellow. Next, let's create our hashmap. Our hashmap is named scores, and just like vectors and strings, we can use the new function. Lastly, let's populate our hashmap. To add entries into our hashmap, we use the insert function, and then we specify the key and value. So the keys are our team name, and the value is our team score. Team blue has a score of 10, and team yellow has a score of 50. Note that we are not passing in the strings by reference, so passing in blue and yellow here will actually move the ownership of those strings into the hashmap. We can see this if we try to print the blue string after these two insert statements. Here, we get an error saying we cannot borrow a moved value. If we didn't want the hashmap to take ownership of our string, we could pass in a reference to our string, but that would require the use of lifetimes, which we'll talk about in chapter 10. We can get individual values out of a hashmap by using the get method and specifying a key like so. Here, we create a variable called team name and assign it to the string blue, and then we call scores.get and pass it a reference to our string. The get method takes a reference to a key and returns an optional value. So you can see here that score is an option that may contain a reference to our integer. The reason we get an option here is because we can't guarantee that a value will be returned. Imagine for example, if you passed in an invalid key. In that case, we would return none. We can also iterate over all the elements in our hashmap like so. Here, we're using a foreign loop, and we're extracting out a tuple that contains the key and value, and then we're just printing out the key and value pair. Now let's talk about updating our hash map. Again, we'll use the game example with teams and scores. We have our scores hash map. Underneath, we have two insert statements. The first insert statement takes the key blue and inserts the value 10. The second insert statement also takes the key blue and inserts 20. What this will do is overwrite the blue key with the value 20. If we don't want to overwrite existing values, we can use the syntax below. First, we call scores.entry, which will give us an entry enum that represents the value for a given key. In this case, the key is yellow. And then we can call methods on that enum. In this case, we're calling or insert. This line of code is saying if there isn't an entry for the yellow key, then insert a new entry with the value 30. However, if there is an entry, then do nothing. So for this first line, yellow doesn't exist. So we'll create a new entry for yellow with the value 30. But on the second line, yellow does exist. So we don't do anything. Now let's look at an example in which we want to update a value in our hash map based on an old value. Here we have a string, hello world wonderful world. And then we create a hash map. And what we want to do is to populate our hash map with the word count in our string. So for example, hello would be a key and its value will be one because it only appears once in the string. World would also be a key and its value would be two because it appears twice in the string. And wonderful would be a key with the value one because it appears once in this string. So to do this first, we call text dot split white space, which we'll take our text here and create a collection of words split by white space. So the first word will be hello and then world wonderful and then world again. Then we'll iterate over that collection using the for in loop. Now this is where it gets interesting inside our for in loop, we take the word and call map dot entry passing in the word. Remember this returns an enum representing the value at that key which could be an existing value or no value at all. And then we call or insert zero. So what this will do is if the word doesn't already exist, it will add the word to our hash map and initialize its value to zero. And if it does exist, it won't do anything. But the interesting part here is that the or insert function returns a mutable reference to our value. So now that we have a mutable reference to our value, we can dereference it and add one to increment it. Let's go through this together. First, I'll add a comment above our foreign loop so we can see what our collection looks like. So for our first iteration, word will be hello. And then we call the or insert function. Because we don't have an entry for hello yet, we will make a new entry and initialize the value to zero. Then we'll get back a mutable reference to our value, which is zero. And then we'll increment it to one. We'll do the same thing for world and set its value to one. And then also the same thing for wonderful. Then we get to our last entry, which is world. In this case, calling or insert won't do anything. But we'll still get back a mutable reference to our value, which is one. And then we'll increment our value to two. And after the loop, we can print out our hash map filled with word counts. So let's go ahead and run our program. And as you can see, hello is set to one, world is set to two, and wonderful is set to one, as expected. And there you have it. Chapter eight of the Rustling book complete. We learned about vectors, strings, and all the complexities that come with strings and hash maps. If you enjoyed this video, make sure to give it a like. And if you want to see Rust content on a weekly basis, make sure to hit subscribe. Lastly, if you have a Rust topic you want me to cover, go ahead and leave a comment down below. And with that, I'll see you in the next one.