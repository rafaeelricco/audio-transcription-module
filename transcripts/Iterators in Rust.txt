 welcome back rust gang if you're new here my name is bogdan and this youtube channel is all about the rust programming language so if you want to see weekly rust videos go ahead and hit the subscribe button in the last video we started chapter 13 of the rustling book by talking about closures if you haven't seen that video make sure to check it out in this video we're going to continue chapter 13 by talking about iterators so with that let's get rusty before we jump into code let's talk about what the iterator pattern is the iterator pattern allows you to iterate over a sequence of elements regardless of how the elements are stored for example the elements could be stored in an array but they could also be stored in a hash map or a graph or some custom data structure that you create iterators encapsulate the logic for iterating over these different data structures iterating over an array is simple you start at index zero and you increment the index but iterating over a map or a custom data structure is not as obvious so again iterators will encapsulate the logic for iterating over these data structures this allows you to iterate over various data structures in a uniform way so with that background let's jump into some code in the following example we create a variable called v1 which is equal to a vector and then we create a variable called v1 underscore iter which will be an iterator over the vector and we can create this iterator by calling v1 dot iter note that in rust iterators are lazy so on line four when we create an iterator nothing special happens until we actually use the iterator so let's use our iterator in a for loop we'll type in for value in our v1 iter and then we'll print out the value let's go ahead and run our program and run our program and you can see we got our vector values printed out now the nice thing here is our for loop was able to use our iterator without any extra code and that's because iterators are part of rust's standard library now in this example we're using a vector but again iterators could be implemented for any data structure and notice that with our for loop we don't have any logic that specifies how to iterate over our sequence of elements because that logic is encapsulated within the iterator now let's talk about how iterators work all iterators in rust implement the iterator trait which is defined in rust's standard library and it looks something like this now notice there's some new syntax here we have a type called item and then we use our item type inside our option return value this is called an associated type and we'll learn more about associated types in chapter 19. this code is saying that when implementing the iterator trait you also have to define the item type and that type is returned from our next method as you can see iterators are pretty simple there's only one method you have to implement which is the next method all the other methods have default implementations the next method returns the next item in the iteration wrapped in sum and when we get to the end of the iteration it returns none notice that we also need a mutable reference to self and that's because calling next changes the internal state of the iterator used to track where it is in the sequence below our iterator trait we can define a test function to demonstrate how the next method works here we create a vector with three elements and then we create this variable to store our iterator and notice that the variable has to be mutable because again we're going to call next and next needs a mutable reference to the iterator then we have a few assert equals statements when we call next for the first time we expect to get back a reference to one inside of sum in the next call we expect a reference to two then a reference to three and finally none because we're at the end of our sequence note that our iterator returns immutable references if we wanted mutable references instead of iter we would type iter underscore mute and if we wanted own types we would use into iter instead let's go ahead and run our test function function and you can see that it passes now the iterator trait has various methods which have default implementations provided by the standard library there are two broad categories of methods adapters which take in an iterator and return another iterator and consumers which take in an iterator and return some other types such as an integer collection or any other type here's an example using the sum method we have a vector of three elements then we create an iterator and then we call sum on our iterator some will repeatedly call the next method to get each element in the sequence and then add those elements up and return the sum in this case we're storing our sum in a variable called total and we're asserting that total is equal to six so let's go ahead and run our test suite and this time we have two passing tests next let's look at adapter methods one such method is map which takes in a closure and creates an iterator which calls the closure over each element in the sequence notice we get a warning here which states that map is unused because map returns an iterator and remember in rest iterators are lazy so this won't actually do anything until we use a consumer method let's fix this by using the collect consumer method which will take our iterator and transform it into a collection then we'll assert that all the elements in our vector are incremented by one now let's go ahead and run our program and it didn't panic which means that we got the correct vector in this next example we'll look at using iterators with closures that capture their environment we have a shoe struct which represents a single shoe and the fields are size which is the size of the shoe and style for the style of the shoe underneath we have a function called shoes in my size which takes a vector of shoes and a shoe size the goal of this function is to filter the shoes vector to only shoes that match the specified shoe size let's look at the function signature we take in parameter called shoes which is a vector of shoes and notice this is not a reference so we're actually taking ownership of the vector and then we take another parameter called shoe size which is an integer and finally we return a vector of shoes inside the function body we call into iter on our shoes vector which will create an iterator that takes ownership of our vector then we call the filter method which accepts a closure which will be called for every element in our iterator filter creates another iterator if the closure passed into the filter returns true for a specific element then that element will be included in the resulting iterator however if it returns false then that element will not be included in the resulting iterator finally we call collect which will take the iterator returned from a filter and transform it into a collection in this case our collection will be a vector of shoes now going back to filter inside this closure we check that the size of the current shoe is equal to the shoe size being passed into our function this is an example of how closures capture their environment shoe size is not defined within the closure but we still have access to it underneath our function we have a test module with one test called filters by size inside the test we create a variable called shoes which is a vector of shoes the first shoe is of size 10 then we have a shoe of size 13 and another shoe of size 10. next we call our shoes in my size function and pass it the shoes we just created and the size 10 and then we store that in a variable called in my size finally we assert that in my size is a vector that only contains shoes of size 10. let's go ahead and run our test suite and our filters by size test is passing now that we've learned how to use iterators in this final section we'll learn how to implement our own iterator for demonstration purposes our iterator is only ever going to count from one to five first we'll create a struct to hold some values in this case our struct is named counter and has one field called count which is an integer and then we're going to implement a constructor function called new which will construct a new counter and set count to zero the count field will keep track of where we are in the process of iterating from one to five and the field is private because we want the field only to be accessed by our implementation block and because we have this new constructor which sets count equals to zero we're enforcing that every time a new counter is created count gets initialized to zero next we'll implement the iterator trait for counter here we've specified our item associated type and set it equal to an unsigned 32-bit integer again we'll learn more about associated types in chapter 19 but all we're saying here is that our iterator is going to return items of type unsigned 32-bit integer then we implement the next method and remember next is the only method we're required to implement next takes a mutable reference to self and returns an option enum which holds the item inside the method body we check if self.count is less than five and if so we increment self.count and then return it otherwise if self.count is equal or greater than five then we return none because we're at the end of our iteration next we'll add a test function that uses our next method our function is called calling next directly inside we create a new counter instance and then call counter.next six times for the first five calls we expect to get a number sequence from one to five and on the sixth call we expect to get none because our sequence is over let's go ahead and run our test and you can see we have a passing test now the standard library provides default implementations for a lot of other methods on our iterator so let's write another test that takes advantage of those now this is an extremely contrived example but let's go through it we're creating a variable called sum which is an integer and it's equal to this expression here first we're creating a new counter and then we're calling the zip method on it the zip iterator will take two iterators and zip them up into one iterator containing pairs of values the first iterator will be the iterator which the method is called on and the second iterator is passed into the method here we're creating a new counter and calling the skip method which is an adapter method meaning it will return another iterator skip will create an iterator that skips the first n elements and being the number passed in so in this case this iterator will skip the first element now zip will return an iterator so then on that iterator we call map map takes a closure which you will call for each item in the iterator in this case each item has a pair of values because we just call the zip method in our closure we'll take these two items and multiply them then we call the filter method and filter to only the items that are divisible by three and finally we call the sum consumer method which will take all the items in our iterator and calculate the sum and after all of that the sum should be equal to 18. let's run our test suite to see if this is true and there you go we have two passing tests now again this is an extremely contrived example but it just goes to show that simply implementing the next method gives us access to all these other methods that have default implementations that's it for part two of chapter 13. if you enjoy this video make sure to give that like button a little poke in the next video we're going to be using our knowledge of iterators to refactor the cli program we made in chapter 12. so if you want to be notified when that video comes out and all the future videos after that make sure to hit subscribe and with that i'll see you in the next one